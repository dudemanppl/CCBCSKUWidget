/* eslint-disable no-unused-vars */
/** Initializes global variables */

const onCompetitiveCyclist =
  window.location.host === 'www.competitivecyclist.com';
const siteString = onCompetitiveCyclist ? 'cc' : 'bc';
const onPLP = document.getElementsByClassName('search-results').length;
const onPDP = document.getElementsByClassName('js-kraken-pdp-body').length;

chrome.runtime.sendMessage({ onCompetitiveCyclist });
/**
 * Returns new HTML element given a tagName. Options to add id or classes.
 *
 * @param {string} tagName HTML tag name
 * @param {?array|string} [classList] Desired classes to add.
 * @param {?string} [id] Id for HTML element
 * @param {?string} [textContent] Text content inside new element
 */

const HTMLElem = (tagName, classList, id, textContent) => {
  const newHTMLElem = document.createElement(tagName);

  if (classList) {
    if (Array.isArray(classList)) {
      newHTMLElem.classList.add(...classList);
    } else {
      throw new TypeError('Expected an array');
    }
  }

  if (id) {
    newHTMLElem.id = id;
  }

  if (textContent) {
    newHTMLElem.textContent = textContent;
  }

  return newHTMLElem;
};

/**
 * Creates a button that links to WMS inventory page of desired product ID
 *
 * @param {string} productID Parent SKU for item from CC/BC catalog
 */

const WMSLink = (productID) => {
  const newWMSLink = HTMLElem(
    'a',
    classnamesForElem('WMSLink'),
    null,
    'Go to WMS'
  );

  newWMSLink.setAttribute('type', 'button');
  newWMSLink.href = `https://manager.backcountry.com/manager/admin/item_inventory.html?item_id=${productID}`;

  return newWMSLink;
};

const classnamesForElem = (elem) => {
  const classnames = [siteString];

  const add = (...classes) => {
    classnames.push(...classes);
  };

  if (elem === 'WMSLink' || elem === 'CopySKUButton') {
    add('btn', 'btn-reset');
    if (onPDP) {
      add('pdp');
      if (onCompetitiveCyclist) {
        add('btn--secondary');
      } else {
        add('product-buybox__btn');
      }
    } else {
      add('plp');
    }
  }

  if (elem === 'WMSLink') {
    add('link-to-wms');
  }

  if (elem === 'PLPPrice') {
    add(
      'ui-pl-pricing__high-price',
      'ui-pl-pricing--price-retail',
      'js-item-price-high',
      'qa-item-price-high'
    );
  }

  return classnames;
};

const copySKUButtonOnClick = ({ currentTarget: copySKUButton }) => {
  const SKU = document.getElementsByClassName('js-selected-product-variant')[0]
    .value;

  if (SKU) {
    navigator.clipboard.writeText(SKU);
    copySKUButton.textContent = 'Copied!';
    copySKUButton.classList.add('flash');

    setTimeout(() => {
      copySKUButton.classList.remove('flash');
    }, 100);
  } else {
    copySKUButton.textContent = 'Choose Item';
    copySKUButton.classList.add('no-variant-selected');
  }
};

const copySKUButtonOnMouseLeave = ({ currentTarget: copySKUButton }) => {
  copySKUButton.textContent = 'Copy SKU';
  copySKUButton.classList.remove('no-variant-selected');
};

const addMethodsToCopySKUButton = (copySKUButton) => {
  copySKUButton.onmouseleave = copySKUButtonOnMouseLeave;
  copySKUButton.onclick = copySKUButtonOnClick;
};

/**
 * Creates a button to copy the full SKU of the selected variant on the PDP
 *
 * @returns {Element}
 */

const copySKUButton = () => {
  const newCopySKUButton = HTMLElem(
    'button',
    classnamesForElem('CopySKUButton'),
    'copy-sku-button',
    'Copy SKU'
  );
  newCopySKUButton.setAttribute('type', 'button');

  addMethodsToCopySKUButton(newCopySKUButton);

  return newCopySKUButton;
};

/**
 * Changes styling of dropdown options to reflect OOS status on CC PDP
 *
 * ONLY WORKS IN WINDOW CONTEXT
 */

const addOOSAlertToCCPDP = () => {
  for (const dropdownOption of document.getElementsByClassName(
    'js-unifiedropdown-option'
  )) {
    const SKU = dropdownOption.getAttribute('sku-value');

    if (SKU && !BC.product.skusCollection[SKU].inventory) {
      dropdownOption.classList.add('oos-alert');
    }
  }
};

/**
 * @param {function} func Minified anonymous ES6 function with no args
 * @return {string}
 */

const anonFuncToStr = (func) => func.toString().slice(5, -1);

/**
 * Invokes a minified anonymous function that requires window context then removes traces of it
 *
 * @param {function} func Minified anonymous ES6 function with no args
 */

const invokeFuncInWindow = (func) => {
  const scriptElem = HTMLElem('script', null, null, anonFuncToStr(func));

  document.head.append(scriptElem);

  scriptElem.remove();
};

/**
 * @return {Element} Target location to add PDP buttons to
 */

const PDPTargetLocation = () => {
  const [targetLocation] = document.getElementsByClassName(
    onCompetitiveCyclist ? 'add-to-cart' : 'js-buybox-actions'
  );

  return targetLocation;
};

/**
 * @return {string} Parent SKU of the PDP shown
 */

const PDPProductID = () => {
  const { value: productID } = document.querySelector(
    '[name ="/atg/commerce/order/purchase/CartModifierFormHandler.productId"]'
  );

  return productID;
};

/* istanbul ignore next */
if (onPDP) {
  if (onCompetitiveCyclist) invokeFuncInWindow(addOOSAlertToCCPDP);

  PDPTargetLocation().append(WMSLink(PDPProductID()), copySKUButton());
}

/**
 * Creates dropdown caret for BC
 */

const BCDropdownCaret = () => {
  const newBCDropdownCaret = document.createElementNS(
    'http://www.w3.org/2000/svg',
    'svg'
  );

  newBCDropdownCaret.classList.add('bc-dropdown-caret');
  newBCDropdownCaret.setAttribute('viewBox', '0 0 256 256');

  const svgPath = document.createElementNS(
    'http://www.w3.org/2000/svg',
    'path'
  );

  svgPath.setAttribute(
    'd',
    'M203.628 107.72c-5.613 5.9-64.759 63.566-64.759 63.566-3.007 3.149-6.939 4.714-10.87 4.714-3.945 0-7.876-1.567-10.87-4.714 0 0-59.145-57.665-64.773-63.565-5.613-5.9-6-16.501 0-22.812 6.014-6.296 14.386-6.79 21.738 0l53.905 52.908 53.891-52.894c7.365-6.79 15.752-6.296 21.738 0 6.014 6.296 5.641 16.912 0 22.797z'
  );

  svgPath.classList.add('caret-path');

  newBCDropdownCaret.append(svgPath);

  return newBCDropdownCaret;
};

/**
 * Returns boolean of whether or not the dropdown has been opened for a particular item
 *
 * @param {Element} target Location to check if the PLP dropdown has been previously opened
 * @return {boolean}
 */

const PLPDropdownOpened = ({ classList: [elementClass] }) => {
  return elementClass === 'plp-dropdown-options';
};

/**
 * @param {Event} event From event handler
 * @param {string} productID Parent SKU for item from CC/BC catalog
 * @param {Element} productListing PLI product listing where widget was
 */

const openPLPDropdownOptions = async (
  event,
  productID,
  productListing,
  state
) => {
  const { currentTarget } = event;
  const { firstChild: currentOption, lastChild } = currentTarget;

  if (PLPDropdownOpened(lastChild)) {
    lastChild.classList.toggle('hidden');
  } else {
    /** Element won't be created until it is clicked */
    currentTarget.append(
      await PLPSelectorDropdown(productID, currentOption, productListing, state)
    );
  }
};

/**
 * @param {Element} PLPSelectorDropdownContainer
 */

const closePLPDropdownOptions = (PLPSelectorDropdownContainer) => {
  const { lastChild } = PLPSelectorDropdownContainer;

  if (PLPDropdownOpened(lastChild)) {
    lastChild.classList.add('hidden');
  }
};

/**
 * Opens and closes the dropdown options on PLP
 *
 * @param {string} productID Parent SKU for item from CC/BC catalog
 * @param {Element} productListing PLI product listing where widget was added
 * @param {Element} PLPSelectorDropdownContainer
 */

const dropdownContainerEventHandlers = (
  productID,
  productListing,
  PLPSelectorDropdownContainer,
  state
) => {
  PLPSelectorDropdownContainer.onclick = (event) =>
    openPLPDropdownOptions(event, productID, productListing, state);

  productListing.onmouseleave = () => {
    closePLPDropdownOptions(PLPSelectorDropdownContainer);
  };
};

/**
 * Creates element that lists the currently selected variant
 * @return {Element}
 */

const PLPDropdownCurrSelectedVariant = () => {
  return HTMLElem(
    'div',
    ['plp-dropdown-curr-selected-variant', siteString],
    null,
    'Select option'
  );
};

/**
 * Creates container for PLP variant selector
 *
 * @param {string} productID Parent SKU for item from CC/BC catalog
 * @param {Element} productListing PLI product listing where widget was added
 * @return {Element}
 */

const PLPSelectorDropdownContainer = (productID, productListing) => {
  const newPLPSelectorDropdownContainer = HTMLElem('div', [
    'plp-dropdown-container',
    siteString,
  ]);

  const state = {
    variantSelected: false,
    currentlySelectedOptionIdx: -1,
    variantImgSrc: null,
  };

  newPLPSelectorDropdownContainer.append(PLPDropdownCurrSelectedVariant());
  /** Adds caret to BC PLP dropdown to mimic BC PDP */
  if (!onCompetitiveCyclist) {
    newPLPSelectorDropdownContainer.append(BCDropdownCaret());
  }

  dropdownContainerEventHandlers(
    productID,
    productListing,
    newPLPSelectorDropdownContainer,
    state
  );

  return newPLPSelectorDropdownContainer;
};

/**
 * Returns JSON response of HTTP get request
 *
 * @param {string} url URL to send request to
 * @return {Object}
 */

const fetchJson = async (url) => {
  const response = await fetch(url);
  const json = response.json();

  return json;
};

/**
 * Returns item information for a product ID from CC/BC catalog
 *
 * @param {string} productID Parent SKU for item from CC/BC catalog
 * @return {Object}
 */

const getItemInfo = async (productID) => {
  const url = `https://api.backcountry.com/v1/products/${productID}?fields=skus.availability.stockLevel,skus.title,skus.id,skus.salePrice,skus.image&site=${
    onCompetitiveCyclist ? 'competitivecyclist' : 'bcs'
  }`;
  const itemInfo = await fetchJson(url);

  return itemInfo;
};

/**
 * Returns array of variants for a product id
 *
 * @param {string} productID Parent SKU for item from CC/BC catalog
 * @return {Object[]}
 */

const getVariants = async (productID) => {
  const itemInfo = await getItemInfo(productID);

  const {
    products: [{ skus: variants }],
  } = itemInfo;

  return variants;
};

/**
 * Formats number in to string in form of $xx.xx
 *
 * @param {number} num
 * @return {string} In form of $xx.xx
 */

const usdString = (num) => {
  const usdString = new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 2,
  }).format(num);

  return usdString;
};

/**
 * Formats a product to be more easily usable
 *
 * @param {Object} product Original product to take values from
 * @return {Object}
 */

const formatVariant = ({
  salePrice,
  id,
  availability: { stockLevel },
  title,
  image: { url },
}) => {
  const formattedVariant = {
    price: usdString(salePrice),
    SKU: id,
    outOfStock: !stockLevel,
    variant: title,
    imageSrc: `https://content.${
      onCompetitiveCyclist ? 'competitivecyclist' : 'backcountry'
    }.com${url}`,
  };

  return formattedVariant;
};

/**
 * Toggles classname of given element to highlight/unhighlight it
 *
 * @param {Element} PLPSelectorDropdown
 * @param {Object} state Current state of parent component
 * @param {number} state.currentlySelectedOptionIdx Index of the currently selected option
 */

const toggleCurrOptionClass = (PLPSelectorDropdown, state) => {
  PLPSelectorDropdown.childNodes[
    state.currentlySelectedOptionIdx
  ].classList.toggle('curr-selected-option');
};

/**
 * Highlights the selected option on a PLP dropdown
 *
 * @param {number} newlySelectectedIdx Index of newly selected option
 */

/**
 * Highlights the selected option on a PLP dropdown
 *
 * @param {Element} PLPSelectorDropdown
 * @param {Object} state
 * @param {number} newlySelectectedIdx Index of newly selected option
 */

const highlightCurrSelectedOption = (
  PLPSelectorDropdown,
  state,
  newlySelectectedIdx
) => {
  if (newlySelectectedIdx !== state.currentlySelectedOptionIdx) {
    if (state.currentlySelectedOptionIdx >= 0) {
      toggleCurrOptionClass(PLPSelectorDropdown, state);
    }

    state.currentlySelectedOptionIdx = newlySelectectedIdx;
    toggleCurrOptionClass(PLPSelectorDropdown, state);
  }
};

/**
 * Returns tuple of elements with price and image to pass to event handlers
 *
 * @param {Element} productListing PLI product listing where widget was added
 * @return {array}
 */

const productListingElems = (productListing) => {
  const [productListingImg] = productListing.getElementsByTagName('img');
  const [productListingPrice] = productListing.getElementsByClassName(
    'js-pl-pricing'
  );

  const productListingElems = [productListingImg, productListingPrice];

  return productListingElems;
};

/**
 * Adds all options to the dropdown
 *
 * @param {string} productID Parent SKU for item from CC/BC catalog
 */

/* istanbul ignore next */

const dropdownOptions = async (
  productID,
  currentOption,
  productListing,
  state,
  PLPSelectorDropdown
) => {
  const variants = await getVariants(productID);

  const dropdownOptions = variants.map((variant, index) =>
    PLPSelectorDropdownOption(
      formatVariant(variant),
      state,
      currentOption,
      productListingElems(productListing),
      () => highlightCurrSelectedOption(PLPSelectorDropdown, state, index)
    )
  );

  return dropdownOptions;
};

/**
 * Creates variant selector dropdown on PLP with price and stock information
 *
 * @return {Element}
 */

/* istanbul ignore next */
const PLPSelectorDropdown = async (...args) => {
  const newPLPSelectorDropdown = HTMLElem('ul', [
    'plp-dropdown-options',
    siteString,
  ]);

  const options = await dropdownOptions(...args, newPLPSelectorDropdown);

  newPLPSelectorDropdown.append(...options);

  return newPLPSelectorDropdown;
};

/**
 * Updates pricing shown on PLP if variant pricing changes
 * @param {Element} productListingPrice Reference to the element with pricing information
 * @param {boolean} props.variantSelected Boolean of whether or not an variant has been selected from the current dropdown
 * @param {string} price Sale price of an item
 */

const updatePricingPLP = (productListingPrice, props, price) => {
  const { variantSelected } = props;

  if (productListingPrice.firstChild.textContent !== price && variantSelected) {
    productListingPrice.firstChild.textContent = price;
  } else if (!variantSelected) {
    /** Removes current elements related to price if variant has not been selected yet */
    while (productListingPrice.lastChild) {
      productListingPrice.lastChild.remove();
    }

    productListingPrice.append(
      HTMLElem('span', classnamesForElem('PLPPrice'), null, price)
    );

    props.variantSelected = true;
  }
};

/**
 *
 * @param {Element} currentOption Reference to HTML elem with the current option chosen
 * @param {string} variant Name of the variant of the item
 * @param {string} SKU Child SKU of an item
 */

const copySKUPLP = (currentOption, variant, SKU) => {
  /** Copies SKU to clipboard */
  navigator.clipboard.writeText(SKU);
  /** Shows short notification of copy */
  currentOption.classList.toggle('copy-notif');
  currentOption.textContent = 'SKU Copied!';

  setTimeout(() => {
    currentOption.classList.toggle('copy-notif');
    currentOption.textContent = variant;
  }, 300);
};

/**
 * @param {Element} PLPSelectorDropdownOption Single PLP selector dropdown option
 * @param {object} product Object containing info about an item
 * @param {string} product.price Sale price of an item
 * @param {string} product.SKU Child SKU of an item
 * @param {boolean} product.outOfStock Whether the item is out of stock or not
 * @param {string} product.variant Name of the variant of the item
 * @param {string} product.imageSrc URL of the source of the image of the item
 * @param {object} props Props passed down from parent
 * @param {Element} currentOption Reference to HTML elem with the current option chosen
 * @param {Element} productListingImg Reference to image of current product listing
 * @param {Element} productListingPrice Reference to the element with pricing information
 * @param {function} highlightCurrSelectedOption Function to change the highlighting of the currently selected variant
 */

const singleOptionEventHandlers = (
  PLPSelectorDropdownOption,
  { price, SKU, outOfStock, variant, imageSrc },
  props,
  currentOption,
  [productListingImg, productListingPrice],
  highlightCurrSelectedOption
) => {
  /** Adds OOS alert as necessary */
  if (outOfStock) PLPSelectorDropdownOption.classList.add('oos-alert');

  PLPSelectorDropdownOption.onmouseenter = () => {
    /** Changes image source if variant image changes */
    if (productListingImg.src !== imageSrc) {
      productListingImg.src = imageSrc;
    }
  };

  /* istanbul ignore next */
  PLPSelectorDropdownOption.onclick = () => {
    highlightCurrSelectedOption();
    updatePricingPLP(productListingPrice, props, price);
    copySKUPLP(currentOption, variant, SKU);
  };
};

/**
 * Creates single dropdown option
 *
 * @param {Object} product Object containing info about an item
 */

const PLPSelectorDropdownOption = (product, ...params) => {
  const { variant, price } = product;
  const newPLPSelectorDropdownOption = HTMLElem(
    'li',
    ['plp-dropdown-option-single'],
    null,
    `${variant} (${price})`
  );

  singleOptionEventHandlers(newPLPSelectorDropdownOption, product, ...params);

  return newPLPSelectorDropdownOption;
};

/**
 * Runs a function on each element of a given class
 *
 * @param {string} elemClassName HTML element class
 * @callback func
 */

const runOnAllElemsOfClass = (elemClassName, func) => {
  const elems = [...document.getElementsByClassName(elemClassName)];

  for (const elem of elems) {
    func(elem);
  }
};

/**
 * Deletes all elements of a given class
 *
 * @param {string} elemClassName HTML element class
 */

const deleteAllElemsOfClass = (elemClassName) => {
  runOnAllElemsOfClass(elemClassName, (elem) => elem.remove());
};

/**
 * Forces styling on BC to prevent onhover zoom effect, which sorta messes with the extension.
 */

const fixBCStyling = () => {
  deleteAllElemsOfClass('js-pl-focus-trigger');
  deleteAllElemsOfClass('js-pl-color-thumbs');
  deleteAllElemsOfClass('js-pl-sizes-wrap');
  runOnAllElemsOfClass('js-pl-expandable', ({ style }) => {
    style.top = '10px';
    style.right = '10px';
    style.bottom = '10px';
    style.left = '10px';
  });
};

/**
 * Creates main SKU Widget container for PLP
 *
 * @param {string} productID Parent SKU for item from CC/BC catalog
 * @param {Element} productListing PLP product listing where widget was added
 */

const PLPWidgetContainer = (productID, productListing) => {
  const newPLPWidgetContainer = HTMLElem('div', ['plp-widget-container']);

  newPLPWidgetContainer.append(
    PLPSelectorDropdownContainer(productID, productListing),
    WMSLink(productID)
  );

  return newPLPWidgetContainer;
};

/**
 * Adds single widget to the PLP
 *
 * @param {Element} productListing PLP product listing
 */

const addPLPSingleWidget = (productListing) => {
  const productID = productListing.getAttribute('data-product-id');
  const targetLocation = productListing.firstChild;

  targetLocation.append(PLPWidgetContainer(productID, targetLocation));
};

/**
 * Adds all widgets to DOM
 */

const addAllPLPWidgets = () => {
  if (!onCompetitiveCyclist) {
    fixBCStyling();
  }
  runOnAllElemsOfClass('js-product-listing', (productListing) =>
    addPLPSingleWidget(productListing)
  );
};

/**
 * @return {Element} Node to observe for changes on the PLP
 */

const nodeToObservePLP = () => {
  const [nodeToObserve] = document.getElementsByClassName(
    onCompetitiveCyclist ? 'js-inner-body' : 'inner-body'
  );

  return nodeToObserve;
};

/* istanbul ignore next */
if (onPLP) {
  addAllPLPWidgets();

  /** Watches for changes on SPA to rerender PLP widgets */
  new MutationObserver(() => addAllPLPWidgets()).observe(nodeToObservePLP(), {
    childList: true,
  });
}

