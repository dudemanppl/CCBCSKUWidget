const onCompetitiveCyclist =
  window.location.host === 'www.competitivecyclist.com';
const siteString = onCompetitiveCyclist ? 'cc' : 'bc';
const pageType = document.getElementById('pageType').content;
const onPLP = pageType.slice(0, 3) === 'plp' || pageType === 'search';
const onPDP = pageType === 'pdp';

/**
 * Returns new HTML element given a tagName. Options to add id or classes.
 *
 * @param {string} tagName HTML tag name
 * @param {?string[]} [classList] Desired classes to add.
 * @param {?string} [id] Id for HTML element
 * @param {?string} [textContent] Text content inside new element
 */

const HTMLElem = (tagName, classList, id, textContent) => {
  const newHTMLElem = document.createElement(tagName);

  if (classList) {
    newHTMLElem.classList.add(...classList);
  }

  if (id) {
    newHTMLElem.id = id;
  }

  if (textContent) {
    newHTMLElem.textContent = textContent;
  }

  return newHTMLElem;
};
 const WMSLinkPDP = (productID) => {
  const newWMSLinkButton = HTMLElem('button', [
    'chakra-button',
    siteString,
    'wms-button-pdp',
  ]);
  const newWMSLink = HTMLElem('a', ['wms-link-pdp'], null, 'Go to WMS');

  newWMSLinkButton.setAttribute('type', 'button');
  newWMSLink.href = `https://manager.backcountry.com/manager/admin/item_inventory.html?item_id=${productID}`;

  newWMSLinkButton.append(newWMSLink);

  return newWMSLinkButton;
};

const copySKUButtonPDP = () => {
  const newCopySKUButton = HTMLElem(
    'button',
    ['chakra-button', siteString, 'copy-sku-button-pdp'],
    null,
    'Copy SKU'
  );

  newCopySKUButton.setAttribute('type', 'button');

  return newCopySKUButton;
};

const getItemsOffered = () => {
  const itemsOfferedElements = document.querySelectorAll(
    '[itemprop="itemOffered"]'
  );

  const items = {};

  for (const item of itemsOfferedElements) {
    const [{ content: variantAndSize }, { content: fullSKU }] = item.children;
    let [variant, size] = variantAndSize.split(`, `);

    // Fix for frames/bikes having cm, which isn't shown on the front end size selector
    if (size.endsWith('cm')) {
      const sizeWithoutCM = size.substring(0, size.length - 2);

      size = sizeWithoutCM;
    }

    items[variant] = { ...items[variant], [size]: fullSKU };
  }

  return items;
};

const iterateThroughChildren = (element, cb, options) => {
  for (const child of element.children) {
    cb(child, options);
  }
};

const changeStylingOfLastChild = (
  { lastChild },
  options = { add: true, classes: [] }
) => {
  if (options.add === false) {
    lastChild.classList.remove(...options.classes);
  } else {
    lastChild.classList.add(...options.classes);
  }
};

const addRedOutline = (parentContainer) => {
  iterateThroughChildren(parentContainer, changeStylingOfLastChild, {
    classes: ['red-outline'],
  });
};

const addRemoveRedOutlineClickListener = (parentContainer) => {
  parentContainer.addEventListener(
    'click',
    () => {
      iterateThroughChildren(parentContainer, changeStylingOfLastChild, {
        add: false,
        classes: ['red-outline'],
      });
    },
    { once: true }
  );
};

if (onPDP) {
  let currentlySelectedVariantSKU;

  const newCopySKUButton = copySKUButtonPDP();

  const copySKU = () => {
    navigator.clipboard.writeText(
      currentlySelectedVariantSKU || 'Error copying SKU'
    );

    newCopySKUButton.textContent = 'Copied!';
  };

  newCopySKUButton.onmouseleave = () => {
    newCopySKUButton.textContent = 'Copy SKU';
  };

  const sizeSelectorWrapper = document.getElementById('buybox-variant-selector').lastElementChild.lastChild;

  newCopySKUButton.onclick = () => {
    const currentlySelectedSize = !JSON.parse(document.querySelector("#__NEXT_DATA__").innerText).props.pageProps.product.selectedSize;

    if (!currentlySelectedSize) {
      addRedOutline(sizeSelectorWrapper);
      addRemoveRedOutlineClickListener(sizeSelectorWrapper);

      newCopySKUButton.textContent = 'Select a Size';
    } else {
      const fullSKU = JSON.parse(document.querySelector("#__NEXT_DATA__").innerText).props.pageProps.product.selectedSku;
      currentlySelectedVariantSKU = fullSKU;

      copySKU();
    }
  };

  const PDPTargetLocation = document.getElementById('buybox-variant-selector')
    .nextSibling.nextSibling;

  const parentSKU = document
    .querySelector('[data-id="productId"]')
    .innerText.slice(-7);

  PDPTargetLocation.append(WMSLinkPDP(parentSKU), newCopySKUButton);
}
 /**
 * Creates dropdown caret
 */

const dropdownCaret = () => {
  const newDropdownCaret = document.createElementNS(
    'http://www.w3.org/2000/svg',
    'svg'
  );

  newDropdownCaret.classList.add('dropdown-caret');

  if (onCompetitiveCyclist) {
    newDropdownCaret.classList.add('cc');
  }
  newDropdownCaret.setAttribute('viewBox', '0 0 24 24');

  const svgPath = document.createElementNS(
    'http://www.w3.org/2000/svg',
    'path'
  );

  svgPath.setAttribute('d', 'M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z');

  svgPath.classList.add('caret-path');

  newDropdownCaret.append(svgPath);

  return newDropdownCaret;
};
 /**
 * Returns boolean of whether or not the dropdown has been opened for a particular item
 *
 * @param {Element} target Location to check if the PLP dropdown has been previously opened
 * @return {boolean}
 */

const PLPDropdownOpened = ({ classList: [firstClass] }) => {
  return firstClass === 'plp-dropdown-options';
};

/**
 * @param {Event} event From event handler
 * @param {string} productID Parent SKU for item from CC/BC catalog
 * @param {Element[]} productListingElems Tuple of elements with price and image
 * @param {object} state Data about the component
 */

const openPLPDropdownOptions = async (
  { currentTarget },
  productID,
  productListingElems,
  state
) => {
  const { firstChild: currSelectedVariant, lastChild } = currentTarget;

  if (PLPDropdownOpened(lastChild)) {
    lastChild.classList.toggle('hidden');
  } else {
    /** Element won't be created until it is clicked */
    const placeholderDropdown = HTMLElem('UL', [
      'plp-dropdown-options',
      'hidden',
      siteString,
    ]);

    currentTarget.append(placeholderDropdown);

    placeholderDropdown.replaceWith(
      await PLPSelectorDropdown(
        productID,
        currSelectedVariant,
        productListingElems,
        state
      )
    );
  }
};

/**
 * @param {Element} PLPDropdownOptions
 */

const closePLPDropdownOptions = (PLPDropdownOptions) => {
  PLPDropdownOptions.classList.add('hidden');
};

/**
 * Returns tuple of elements with price and image to pass to event handlers
 *
 * @param {Element} productListing PLI product listing where widget was added
 * @return {array}
 */

const productListingElems = (productListing) => {
  const [productListingImg] = productListing.getElementsByTagName('img');
  const productListingPrice = productListing.querySelector(
    '[data-id="productListingPrice"]'
  );

  const productListingElems = [productListingImg, productListingPrice];

  return productListingElems;
};

/**
 * Opens and closes the dropdown options on PLP
 *
 * @param {string} productID Parent SKU for item from CC/BC catalog
 * @param {Element} productListing PLI product listing where widget was added
 * @param {Element} PLPSelectorDropdownContainer
 * @param {object} state Data about the component
 */

const dropdownContainerEventHandlers = (
  productID,
  productListing,
  PLPSelectorDropdownContainer,
  state
) => {
  const [productListingImg, productListingPrice] =
    productListingElems(productListing);

  PLPSelectorDropdownContainer.onclick = (event) =>
    openPLPDropdownOptions(
      event,
      productID,
      [productListingImg, productListingPrice],
      state
    );

  productListing.onmouseleave = () => {
    if (state.variantImgSrc) {
      productListingImg.src = state.variantImgSrc;
    }

    const [PLPSelectorDropdownContainer] =
      productListing.getElementsByClassName('plp-dropdown-options');

    PLPSelectorDropdownContainer &&
      closePLPDropdownOptions(PLPSelectorDropdownContainer);
  };
};

/**
 * Creates element that lists the currently selected variant
 * @return {Element}
 */

const PLPDropdownCurrSelectedVariant = () => {
  return HTMLElem(
    'div',
    ['plp-dropdown-curr-selected-variant', siteString],
    null,
    'Select option'
  );
};

/**
 * Creates container for PLP variant selector
 *
 * @param {string} productID Parent SKU for item from CC/BC catalog
 * @param {Element} productListing PLI product listing where widget was added
 * @return {Element}
 */

const PLPSelectorDropdownContainer = (productID, productListing) => {
  const newPLPSelectorDropdownContainer = HTMLElem('div', [
    'plp-dropdown-container',
    siteString,
  ]);

  const state = {
    currentlySelectedOptionIdx: -1,
    variantImgSrc: null,
  };

  newPLPSelectorDropdownContainer.append(
    PLPDropdownCurrSelectedVariant(),
    dropdownCaret()
  );

  dropdownContainerEventHandlers(
    productID,
    productListing,
    newPLPSelectorDropdownContainer,
    state
  );

  return newPLPSelectorDropdownContainer;
};
 /**
 * Returns JSON response of HTTP get request
 *
 * @param {string} url URL to send request to
 * @return {Object}
 */

const fetchJson = async (url) => {
  const response = await fetch(url);
  const json = response.json();

  return json;
};

/**
 * Returns item information for a product ID from CC/BC catalog
 *
 * @param {string} productID Parent SKU for item from CC/BC catalog
 * @return {Object}
 */

const getItemInfo = async (productID) => {
  const url = `https://api.backcountry.com/v1/products/${productID}?fields=skus.availability.stockLevel,skus.title,skus.id,skus.salePrice,skus.listPrice,skus.image&site=${
    onCompetitiveCyclist ? 'competitivecyclist' : 'bcs'
  }`;
  const itemInfo = await fetchJson(url);

  return itemInfo;
};

/**
 * Returns array of variants for a product id
 *
 * @param {string} productID Parent SKU for item from CC/BC catalog
 * @return {Object[]}
 */

const getVariants = async (productID) => {
  const itemInfo = await getItemInfo(productID);

  const {
    products: [{ skus: variants }],
  } = itemInfo;

  return variants;
};

/**
 * Formats number in to string in form of $xx.xx
 *
 * @param {number} num
 * @return {string} In form of $xx.xx
 */

const usdString = (num) => {
  const usdString = new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 2,
  }).format(num);

  return usdString;
};

/**
 * Formats a product to be more easily usable
 *
 * @param {Object} product Original product to take values from
 * @return {Object}
 */

const formatVariant = ({
  salePrice,
  listPrice,
  id,
  availability: { stockLevel },
  title,
  image: { url },
}) => {
  const discount = Math.round(((listPrice - salePrice) / listPrice) * 100);
  
  const formattedVariant = {
    price: usdString(salePrice),
    discount,
    SKU: id,
    outOfStock: !stockLevel,
    variant: title,
    imageSrc: `https://content.${
      onCompetitiveCyclist ? 'competitivecyclist' : 'backcountry'
    }.com${url}`,
  };

  return formattedVariant;
};

/**
 * Toggles classname of given element to highlight/unhighlight it
 *
 * @param {Element} PLPSelectorDropdown
 * @param {object} state Data about the component
 * @param {number} state.currentlySelectedOptionIdx Index of the currently selected option
 */

const toggleCurrOptionClass = (PLPSelectorDropdown, state) => {
  PLPSelectorDropdown.childNodes[
    state.currentlySelectedOptionIdx
  ].classList.toggle('curr-selected-option');
};

/**
 * Highlights the selected option on a PLP dropdown
 *
 * @param {number} newlySelectectedIdx Index of newly selected option
 */

/**
 * Highlights the selected option on a PLP dropdown
 *
 * @param {Element} PLPSelectorDropdown
 * @param {object} state Data about the component
 * @param {number} newlySelectectedIdx Index of newly selected option
 */

const highlightCurrSelectedOption = (
  PLPSelectorDropdown,
  state,
  newlySelectectedIdx
) => {
  if (newlySelectectedIdx !== state.currentlySelectedOptionIdx) {
    if (state.currentlySelectedOptionIdx >= 0) {
      toggleCurrOptionClass(PLPSelectorDropdown, state);
    }

    state.currentlySelectedOptionIdx = newlySelectectedIdx;
    toggleCurrOptionClass(PLPSelectorDropdown, state);
  }
};

/**
 *  Adds all options to the dropdown
 * @param {string} productID Parent SKU for item from CC/BC catalog
 * @param {Element} currSelectedVariant Element that shows the currently selected variant
 * @param {Element[]} productListingElems Tuple of elements with price and image
 * @param {object} state Data about the component
 * @param {Element} PLPSelectorDropdown
 */

/* istanbul ignore next */
const dropdownOptions = async (
  productID,
  currSelectedVariant,
  productListingElems,
  state,
  PLPSelectorDropdown
) => {
  const variants = await getVariants(productID);

  const newDropdownOptions = variants.map((variant, index) =>
    PLPSelectorDropdownOption(
      formatVariant(variant),
      state,
      currSelectedVariant,
      productListingElems,
      () => highlightCurrSelectedOption(PLPSelectorDropdown, state, index)
    )
  );

  return newDropdownOptions;
};

/**
 * Creates variant selector dropdown on PLP with price and stock information
 *
 * @return {Element}
 */

const PLPSelectorDropdown = async (...args) => {
  const newPLPSelectorDropdown = HTMLElem('ul', [
    'plp-dropdown-options',
    siteString,
  ]);

  const options = await dropdownOptions(...args, newPLPSelectorDropdown);

  newPLPSelectorDropdown.append(...options);

  return newPLPSelectorDropdown;
};
 /**
 * Updates pricing shown on PLP if variant pricing changes
 * @param {Element} productListingPrice Reference to the element with pricing information
 * @param {string} price Sale price of an item
 * @param {number} discount Discount in percentage from MSRP
 */

const updatePricingPLP = (productListingPrice, price, discount) => {
  // updates discount percentage, needs more fleshing out tho 
  
  // const {
  //   nextSibling: { lastChild: discountElem },
  // } = productListingPrice;

  // if (discountElem) {
  //   while (discountElem.lastChild) {
  //     discountElem.lastChild.remove();
  //   }
  //   discountElem.textContent = `${discount}% off`;
  // }

  if (productListingPrice.textContent !== price) {
    /** Removes current elements related to price if variant has not been selected yet */
    while (productListingPrice.lastChild) {
      productListingPrice.lastChild.remove();
    }

    productListingPrice.textContent = price;
  }
};

/**
 *
 * @param {Element} currentOption Reference to HTML elem with the current option chosen
 * @param {string} variant Name of the variant of the item
 * @param {string} SKU Child SKU of an item
 */

const copySKUPLP = (currentOption, variant, SKU) => {
  /** Copies SKU to clipboard */
  navigator.clipboard.writeText(SKU);
  /** Shows short notification of copy */
  currentOption.classList.toggle('copy-notif');
  currentOption.textContent = 'SKU Copied!';

  setTimeout(() => {
    currentOption.classList.toggle('copy-notif');
    currentOption.textContent = variant;
  }, 300);
};

/**
 * @param {Element} PLPSelectorDropdownOption Single PLP selector dropdown option
 * @param {object} product Object containing info about an item
 * @param {string} product.price Sale price of an item
 * @param {string} product.SKU Child SKU of an item
 * @param {boolean} product.outOfStock Whether the item is out of stock or not
 * @param {string} product.variant Name of the variant of the item
 * @param {string} product.imageSrc URL of the source of the image of the item
 * @param {object} props Props passed down from parent
 * @param {Element} currentOption Reference to HTML elem with the current option chosen
 * @param {Element} productListingImg Reference to image of current product listing
 * @param {Element} productListingPrice Reference to the element with pricing information
 * @param {function} highlightCurrSelectedOption Function to change the highlighting of the currently selected variant
 */

const singleOptionEventHandlers = (
  PLPSelectorDropdownOption,
  { price, discount, SKU, outOfStock, variant, imageSrc },
  props,
  currentOption,
  [productListingImg, productListingPrice],
  highlightCurrSelectedOption
) => {
  /** Adds OOS alert as necessary */
  if (outOfStock) PLPSelectorDropdownOption.classList.add('oos-alert');

  PLPSelectorDropdownOption.onmouseenter = () => {
    /** Changes image source if variant image changes */
    if (productListingImg.src !== imageSrc) {
      productListingImg.src = imageSrc;
    }
  };

  PLPSelectorDropdownOption.onclick = () => {
    highlightCurrSelectedOption();
    updatePricingPLP(productListingPrice, price, discount);
    copySKUPLP(currentOption, variant, SKU);
    props.variantImgSrc = imageSrc;
  };
};

/**
 * Creates single dropdown option
 *
 * @param {Object} product Object containing info about an item
 */

const PLPSelectorDropdownOption = (product, ...params) => {
  const { variant, price } = product;
  const newPLPSelectorDropdownOption = HTMLElem(
    'li',
    ['plp-dropdown-option-single'],
    null,
    `${variant} (${price})`
  );

  singleOptionEventHandlers(newPLPSelectorDropdownOption, product, ...params);

  return newPLPSelectorDropdownOption;
};
 /**
 * Creates a button that links to WMS inventory page of desired product ID
 *
 * @param {string} productID Parent SKU for item from CC/BC catalog
 */

const WMSLinkPLP = (productID) => {
  const newWMSLinkPLP = HTMLElem(
    'a',
    ['btn', 'btn-reset', 'plp', 'link-to-wms', siteString],
    null,
    'Go to WMS'
  );

  newWMSLinkPLP.setAttribute('type', 'button');
  newWMSLinkPLP.href = `https://manager.backcountry.com/manager/admin/item_inventory.html?item_id=${productID}`;

  return newWMSLinkPLP;
};
/**
 * Creates main SKU Widget container for PLP
 *
 * @param {string} productID Parent SKU for item from CC/BC catalog
 * @param {Element} productListing PLP product listing where widget was added
 */

const PLPWidgetContainer = (productID, productListing) => {
  const newPLPWidgetContainer = HTMLElem('div', [
    'plp-widget-container',
    siteString,
  ]);

  newPLPWidgetContainer.append(
    PLPSelectorDropdownContainer(productID, productListing),
    WMSLinkPLP(productID)
  );

  return newPLPWidgetContainer;
};

/**
 * Adds single widget to the PLP
 *
 * @param {Element} productListing PLP product listing
 */

const addPLPSingleWidget = (productListing) => {
  const imgSrc = productListing.querySelector('img').src;
  const sliceStart = onCompetitiveCyclist ? 60 : 53;
  const sliceIndexs = [sliceStart, sliceStart + 7];

  const productID = imgSrc.slice(...sliceIndexs);

  const targetLocation = productListing.lastChild;

  targetLocation.append(PLPWidgetContainer(productID, targetLocation));
};

/**
 * Adds all widgets to DOM
 */

const addAllPLPWidgets = () => {
  const PLPItems = document.querySelectorAll('[data-id="productListingItems"]');

  for (const productListing of PLPItems) {
    addPLPSingleWidget(productListing);
  }
};

if (onPLP) {
  addAllPLPWidgets();

  const nodeToObservePLP = document.querySelector('[data-id="productsWrap"]');

  /** Watches for changes on SPA to rerender PLP widgets */
  new MutationObserver(() => addAllPLPWidgets()).observe(nodeToObservePLP, {
    childList: true,
  });
}
